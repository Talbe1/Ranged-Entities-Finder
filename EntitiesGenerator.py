import numpy as np
import pandas as pd
import random as rand
from datetime import datetime, timedelta

class EntitiesGenerator:
    """
    Generates entity path data to test RangedEntitiesFinder.
    """

    @staticmethod
    def _generate_entity_path(entity_num: int, num_tracks: int, increments: tuple, starting_loc: tuple) -> pd.DataFrame:
        """
        Generates a path of an entity that doesn't necessarily
        (because it's not programmed to, and thus there is some chance) cross paths with sus.

        :param entity_num: the number of the entity.
        :param num_tracks: the total number of steps.
        :param increments: the change between two points.
        :param starting_loc: the location from which the path is generated.
        :return: a DataFrame that contains the path including timestamps.
        """

        # Generating data
        data = {
            "id": np.repeat(entity_num, num_tracks),
            "ts": timestamps,
            "lat":
                starting_loc[0] + increments[0] *
                np.arange(num_tracks),
            "long":
                starting_loc[1] + increments[1] *
                np.arange(num_tracks),
            "height":
                starting_loc[2] + increments[2] *
                np.arange(num_tracks)
        }

        return pd.DataFrame(data)

    @staticmethod
    def _generate_incomplete_partial_path(entity_num: int, loc_step_start: int,
                                          loc_step_end: int, increments: tuple,
                                          anchor_pos: tuple, forward: bool) -> dict:
        """
        Generates a partial path of an entity using an anchor point and a step number relative to the beginning
        of the whole path (which the partial path this function generates is A PART OF).

        The path is partial as it's not entirely generated at once,
        but rather **from a starting point to an anchor point (will be called backward**), OR
        **from an anchor point to an end point (will be called forward**).

        Note: **the data is incomplete as the timestamps are missing**.
        The caller function has to add them. This design decision was made to simplify
        the code and avoid the complexities previously encountered during development.

        :param entity_num: the number of the entity.
        :param loc_step_start: the step number representing the start of the path generation.
        :param loc_step_end: the step number representing the end of the path generation.
        :param increments: the change between each point in the path.
        :param anchor_pos: used to generate the path from it.
        :param forward: if the path being generated is before the anchor_pos or after. False if before, True if after.
        :return: a dictionary that contains the path of the entity without timestamps.
        """

        delta_steps = np.absolute(loc_step_end - loc_step_start)

        # Checks if the generated path is forwards so that the correct values for np.arange() will be calculated.
        if forward:
            loc_step_start = 1
            loc_step_end = delta_steps + 1

        # Used for generating the path in the proper direction.
        steps_multiplier = 1 if forward else -1

        '''
        Each new point on the path is generated by taking the anchor point,
        multiplying it by the constant increments (per axis) and then by a steps multiplier (steps_multiplier).
        This multiplier is defined by the direction of the path (1 for forward and -1 for backward).
        Function np.arange() is used to create one continuous path per axis.
        '''
        incomplete_path = {
            "id": np.repeat(entity_num, delta_steps),
            "lat":
                anchor_pos[0] + increments[0] * steps_multiplier *
                np.arange(loc_step_start, loc_step_end, steps_multiplier),
            "long":
                anchor_pos[1] + increments[1] * steps_multiplier *
                np.arange(loc_step_start, loc_step_end, steps_multiplier),
            "height":
                anchor_pos[2] + increments[2] * steps_multiplier *
                np.arange(loc_step_start, loc_step_end, steps_multiplier)
        }

        return incomplete_path

    @staticmethod
    def _generate_path_from_anchor(entity_num: int, num_tracks: int, step_num_start: int,
                                   step_num_end: int, increments: tuple,
                                   anchor_loc: tuple) -> pd.DataFrame:
        """
        Generates a path of an entity from a given anchor point.
        Step number is the number of the current relevant data row when looking at the entire path data of a specific entity.
        The whole data recorded about an entity always starts at 1, but the function mostly works with
        a different start and end step numbers.

        IMPORTANT: loc_step_start and loc_step_end are NEVER equal. If they are, the function CANNOT be used for generating a path.

        :param entity_num: the number of the entity.
        :param num_tracks: the number of rows of data.
        :param step_num_start: the step number to start generating the path from.
        :param step_num_end: the step number to stop generating the path at.
        :param increments: the increments to change the coordinates by, in relation to the previous step.
        :param anchor_loc: the anchor point based on which the path is generated.
        :return: a DataFrame that contains the path data of an entity.
        """

        # Generating the partial incomplete path from the beginning to the proximity point.
        # 'loc_multiplier_end - 1' is written as the numpy arange function includes the beginning but not the ending values.
        # For example: np.arange(7, 2, -1) -> array([7, 6, 5, 4, 3])
        beginning_to_proximity = (EntitiesGenerator.
                                  _generate_incomplete_partial_path(entity_num, step_num_start,
                                                                    step_num_end - 1, increments, anchor_loc, False))

        # Calculating position to insert the anchor point to the data.
        insertion_pos = len(beginning_to_proximity["id"])

        # Adding the data of the anchor point.
        beginning_to_proximity["id"] = np.insert(beginning_to_proximity["id"], insertion_pos, entity_num)
        beginning_to_proximity["lat"] = np.insert(beginning_to_proximity["lat"], insertion_pos, anchor_loc[0])
        beginning_to_proximity["long"] = np.insert(beginning_to_proximity["long"], insertion_pos, anchor_loc[1])
        beginning_to_proximity["height"] = np.insert(beginning_to_proximity["height"], insertion_pos, anchor_loc[2])

        # Generating the partial incomplete path after the proximity point all the way to the end.
        # 'loc_multiplier_end + 1' represents the index step number after the proximity location
        # and is written like that as the numpy arange function includes the beginning but not the ending values.
        # For example: np.arange(3) -> array([0, 1, 2])
        after_proximity_to_end = (EntitiesGenerator.
                                  _generate_incomplete_partial_path(entity_num, step_num_end,
                                                                    num_tracks, increments, anchor_loc, True))

        # Creating DataFrame that represents the entire path.
        # Currently only contains the timestamps, the rest of the data is added later.
        entire_path = pd.DataFrame(timestamps, columns=["ts"])
        # print("entire path:\n", entire_path, "\n")
        # The path data without the timestamps.
        path_without_ts = pd.concat([pd.DataFrame(beginning_to_proximity),
                                     pd.DataFrame(after_proximity_to_end)]).reset_index(drop=True)

        # Combining the paths data before, after, and including the proximity point to a single path.
        entire_path = entire_path.join(path_without_ts)

        return entire_path

    @staticmethod
    def _generate_entity_with_target_proximity(entity_num: int, sus_id: int, num_tracks: int) -> pd.DataFrame:
        """
        Generates a path of an entity that has a point in proximity relative to the path of the target entity.

        :param entity_num: the number of the entity.
        :param sus_id: the Id of the target.
        :param num_tracks: the total number of steps.
        :return: a DataFrame that contains the path of a single entity.
        """

        # Calculating indexes of entities for easier data access.
        entity_idx = entity_num - 1

        # Selecting a random timestamp (ts_of_cross_path) from an index (ts_idx_of_cross_path)
        # to be a time when a cross path occurs.
        ts_idx_of_cross_path = rand.randint(0, num_tracks - 1)
        ts_of_cross_path = timestamps[ts_idx_of_cross_path]

        # The row in the DataFrame that contains that data about the entity (such as location) at the time when crossing paths.
        sus_data_at_ts = sus_path[(sus_path["id"] == sus_id) & (sus_path["ts"] == ts_of_cross_path)]

        # Getting the index of sus from the DataFrame.
        sus_idx_in_df = sus_data_at_ts.index[0]

        # .loc is used to make sure the tuple contains only np.float values and not Pandas Series.
        sus_location = (sus_data_at_ts.loc[sus_idx_in_df, "lat"],
                        sus_data_at_ts.loc[sus_idx_in_df, "long"],
                        sus_data_at_ts.loc[sus_idx_in_df, "height"])

        # Generating a location which is close to the location of the suspicious target in the current timestamp recorded.
        proximity_lat = sus_location[0] + np.random.random()
        proximity_long = sus_location[1] + np.random.random()
        proximity_height = sus_location[2] + np.random.random()

        proximity_loc = (proximity_lat, proximity_long, proximity_height)

        # The new increments of the entity whose path is in proximity to the target's, at some point or another.
        increments = (lat_increments[entity_idx], long_increments[entity_idx], height_increments[entity_idx])

        # If the value is equal to 1 then the entire path can be generated as the anchor point (proximity_loc)
        # is the start of the path.
        if ts_idx_of_cross_path == 1:
            entire_path = EntitiesGenerator._generate_entity_path(entity_num, num_tracks, increments, proximity_loc)
            return entire_path

        # Generating the path from a given anchor point.
        path_generated = (EntitiesGenerator.
        _generate_path_from_anchor(
            entity_num, num_tracks, ts_idx_of_cross_path + 1, 1,
            increments, proximity_loc))

        print("\nEntire path:\n", path_generated, "\n\n\n\n")

        return path_generated

    @staticmethod
    def generate_entities_paths(num_entities: int = 5, num_tracks: int = 10, rand_sus_num: bool = False) -> tuple:
        """
        Generates paths of entities based on the amount of tracks (timestamps).
        Some entities cross paths with a suspicious target (sus).

        :param num_entities: the number of entities that will appear in the data.
        :param num_tracks: the number of data rows per entity.
        :param rand_sus_num: True if the user desires to randomize the number of the suspicious target thus every run a different target number will be chosen.
        :return: a tuple that contains the path of all entities (including target), and separately the path of the suspicious target.
        """
        # Making variables global to reduce amount of function arguments of those being called from this function.
        global sus_path, timestamps, starting_positions, starting_heights, lat_increments, long_increments, height_increments

        # Generate a single set of timestamps
        timestamps = [datetime.now() + timedelta(seconds=i) for i in range(num_tracks)]

        # Initialize starting positions and linear increments
        # The defined increments (lat_increments, long_increments, height_increments)
        # are the default increments when an entity does not cross paths with the target (sus).
        starting_positions = np.random.uniform(low=-90, high=90, size=(num_entities, 2))  # Starting lat and long
        starting_heights = np.random.uniform(low=0.0, high=100.0, size=num_entities)  # Starting height
        lat_increments = np.random.uniform(low=-0.1, high=0.1, size=num_entities)  # Lat change per step
        long_increments = np.random.uniform(low=-0.1, high=0.1, size=num_entities)  # Long change per step
        height_increments = np.random.uniform(low=-5.0, high=5.0, size=num_entities)  # Height change per step

        # Giving an initial value to the target entity, as it might not be randomized.
        sus_num = 1
        sus_idx = sus_num - 1

        # Randomizing the sus target.
        if rand_sus_num and num_entities > 1:
            sus_num = rand.randint(2, num_entities)

        # Acquiring the base increments for the current entity. (the increments are being varied ever so slightly)
        increments = (lat_increments[sus_idx],
                      long_increments[sus_idx],
                      height_increments[sus_idx])

        starting_location = (starting_positions[sus_idx, 0], starting_positions[sus_idx, 1], starting_heights[sus_idx])

        # Generating the path of the target entity.
        sus_path = EntitiesGenerator._generate_entity_path(sus_num, num_tracks, increments, starting_location)

        all_entities = pd.DataFrame()

        for current_entity_num in range(1, num_entities + 1):
            if current_entity_num == sus_num:
                # Adding the suspicious entity path to the data of all entities.
                all_entities = pd.concat([all_entities, sus_path]).reset_index(drop=True)
                continue

            # Making entities come in proximity to the target randomly.
            if bool(rand.randint(0, 1)):
                new_entity_data = EntitiesGenerator._generate_entity_with_target_proximity(current_entity_num,
                                                                                           sus_num, num_tracks)

            else:
                current_entity_idx = current_entity_num - 1

                # Acquiring the base increments for the current entity. (the increments are being varied ever so slightly)
                increments = (lat_increments[current_entity_idx],
                              long_increments[current_entity_idx],
                              height_increments[current_entity_idx])

                entity_starting_location = (starting_positions[current_entity_idx, 0],
                                            starting_positions[current_entity_idx, 1],
                                            starting_heights[current_entity_idx])

                new_entity_data = EntitiesGenerator._generate_entity_path(current_entity_num, num_tracks, increments,
                                                                          entity_starting_location)

            all_entities = pd.concat([all_entities, new_entity_data]).reset_index(drop=True)

        # Returning DataFrames in a tuple.
        # The parentheses are NOT redundant (they create a tuple data structure).
        return (all_entities, sus_path)

    @staticmethod
    def generate_entity_id(id_len: int = 5) -> str:
        # Catching a case where length value is incorrect.
        if id_len <= 0: id_len = 5